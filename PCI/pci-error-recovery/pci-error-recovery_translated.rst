.. SPDX-License-Identifier: GPL-2.0


PCI 错误恢复
============


:作者: - Linas Vepstas <linasvepstas@gmail.com>
- Richard Lary <rlary@us.ibm.com>
- Mike Mason <mmlnx@us.ibm.com>


许多PCI总线控制器能够检测多种硬件
总线上的PCI错误，例如数据和地址的奇偶校验错误
公交车，以及SERR和PERR错误。一些更高级的
芯片组能够处理这些错误；其中包括PCIe芯片组，
以及基于 IBM Power4、Power5 和 Power6 的 PCI-主机桥
pSeries 设备。通常采取的操作是断开受影响的设备，
停止向其传输所有 I/O。断开连接的目的是避免系统
腐败；例如，防止因DMA导致的系统内存损坏
到“野生”地址。通常，还会有一个重新连接机制
提供，以便受影响的PCI设备被重置并恢复
恢复到工作状态。重置阶段需要协调
在受影响的设备驱动程序与PCI控制器芯片之间。
本文档描述了一个用于通知设备驱动程序的通用API
总线断开连接，然后执行错误恢复。
该API目前在2.6.16及更高版本的内核中实现。

报告与恢复需通过多个步骤完成。首先，当
PCI硬件错误导致总线断开，该事件
会尽快报告给所有受影响的设备驱动程序，
包括在多功能设备上运行的多个设备驱动程序实例
cards。这使得设备驱动程序能够避免在自旋循环中发生死锁，
等待某个 I/O 空间寄存器发生变化，而它永远不会变。
它还使驱动程序有机会延迟传入的 I/O 操作
需要。

接下来，恢复过程将分几个阶段进行。大部分复杂性
由于需要处理多功能设备，因此被迫如此，即
具有多个设备驱动程序关联的设备。
在第一阶段，每个司机都可以表明自己的类型
它希望重置的次数，选择项为简单地重新启用 I/O
或请求重置插槽。

如果有任何驱动程序请求插槽重置，将会执行该操作。

重置和/或重新启用 I/O 后，所有驱动程序都将
再次通知，以便它们可以执行任何设备设置/配置
可能需要的。在这些全部完成后，一个最终的
“resume normal operations”事件已发出。

选择基于内核实现的最主要原因
比用户空间实现更关键的是需要处理总线
连接到存储介质的PCI设备断开连接，特别是
断开持有根文件系统的设备。如果根
文件系统已断开连接，用户空间机制将不得不进行处理
通过大量扭曲动作来完成恢复。几乎所有的
当前的Linux文件系统对断开连接的容忍度不高
从/重新连接到底层块设备。相比之下，
总线错误在设备驱动程序中很容易处理。事实上，大多数
设备驱动程序已经处理了非常类似的恢复流程；
例如，SCSI-通用层已经提供了显著的功能
处理SCSI总线错误和SCSI总线重置的机制。


详细设计
========

以下是基于一个链式结构的设计与实现细节，
2005年4月5日左右与Ben Herrenschmidt的公开邮件讨论。

错误恢复 API 支持以以下形式向驱动程序提供：
指向结构体中新字段的函数指针结构
pci_driver。未能提供该结构的驱动程序为“非感知型”，
并且实际的恢复步骤取决于平台。
arch/powerpc 实现将模拟一次 PCI 热插拔移除/添加操作。

该结构的形式如下::

	struct pci_error_handlers
	{
		int (*error_detected)(struct pci_dev *dev, pci_channel_state_t);
		int (*mmio_enabled)(struct pci_dev *dev);
		int (*slot_reset)(struct pci_dev *dev);
		void (*resume)(struct pci_dev *dev);
		void (*cor_error_detected)(struct pci_dev *dev);
	};

可能的通道状态有：

	typedef enum {
		pci_channel_io_normal,  /* I/O channel is in normal state */
		pci_channel_io_frozen,  /* I/O to channel is blocked */
		pci_channel_io_perm_failure, /* PCI card is dead */
	} pci_channel_state_t;

可能的返回值包括：

	enum pci_ers_result {
		PCI_ERS_RESULT_NONE,        /* no result/none/not supported in device driver */
		PCI_ERS_RESULT_CAN_RECOVER, /* Device driver can recover without slot reset */
		PCI_ERS_RESULT_NEED_RESET,  /* Device driver wants slot to be reset. */
		PCI_ERS_RESULT_DISCONNECT,  /* Device has completely failed, is unrecoverable */
		PCI_ERS_RESULT_RECOVERED,   /* Device driver is fully recovered and operational */
	};

驱动程序不必实现所有这些回调；但是，
如果实现了任何回调，就必须实现 error_detected()。如果一个回调
未实现，则认为相应功能不受支持。
例如，如果 mmio_enabled() 和 resume() 不存在，那么它
假设驱动程序不需要这些回调函数
用于恢复。通常，驱动程序需要了解有关
一个 slot_reset()。

平台为从PCI错误中恢复所采取的实际步骤
事件将依赖于平台，但会遵循通用的
如下所述的序列。

STEP 0：错误事件
----------------
PCI 硬件检测到 PCI 总线错误。在 powerpc 上，插槽
是隔离的，因为所有 I/O 操作都被阻塞：所有读取操作返回 0xffffffff，
所有写入操作均被忽略。

同样地，在支持下游端口 containment 的平台上
（PCIe r7.0 第6.2.11节），指向具有子层次结构的链路
发生故障的设备已禁用。子层级中的任何设备
变得无法访问。

步骤 1：通知
------------
平台会在每个实例上调用 error_detected() 回调函数
每个受此错误影响的驱动程序。

此时，设备可能已无法再访问，具体取决于
该平台（在powerpc上插槽将被隔离）。驱动程序可能
由于I/O失败，已经“注意到”该错误，但
是正确的“同步点”，也就是说，它为驱动程序
清理的机会，等待待处理的事项（定时器、其他等等……）
以完成；它可以获取信号量、进行调度等……除了……之外的一切操作
触摸设备。在此函数内部以及函数返回后，驱动程序
不应执行任何新的IO操作。在任务上下文中调用。这有点像一种
“静默”点。参见本文末尾关于中断的说明。

所有参与此系统的驱动程序都必须实现此调用。
驱动程序必须返回以下结果代码之一：

- PCI_ERS_RESULT_RECOVERED
驱动程序在认为设备可用时返回此值，即使
该错误无需进一步干预。
- PCI_ERS_RESULT_CAN_RECOVER
驱动程序在认为可能能够恢复时返回此值
硬件通过直接敲击IO来操作，还是希望被赋予某种方式
提取一些诊断信息的机会（参见
mmio_enable，如下所述）。
- PCI_ERS_RESULT_NEED_RESET
如果驱动程序无法在不进行恢复的情况下继续，则返回此值
插槽已重置。
- PCI_ERS_RESULT_DISCONNECT
如果驱动程序完全不想进行恢复，则返回此值。

下一步操作将取决于返回的结果代码。
驱动程序。

如果该段/槽位上的所有驱动程序都返回 PCI_ERS_RESULT_CAN_RECOVER，
然后平台应重新启用该插槽上的IO（或不做任何操作）
特别是，如果平台没有隔离插槽），以及恢复
进入步骤2（MMIO启用）。

如果有任何驱动程序请求插槽重置（通过返回 PCI_ERS_RESULT_NEED_RESET），
然后恢复过程进入步骤4（插槽重置）。

如果平台无法恢复该插槽，则下一步
是步骤6（永久性故障）。

.. note::

当前的powerpc实现假设设备驱动程序将
*不*要在本例程中进行调度或信号量操作；当前的powerpc
实现使用一个内核线程来通知所有设备；
因此，如果一个设备进入休眠或进行调度，所有设备都会受到影响。
做得更好需要在错误处理中实现复杂的多线程逻辑
恢复实现（例如，等待所有通知线程）
在继续恢复之前需要先“加入”。这似乎过于
复杂且不值得实现。

当前的 powerpc 实现并不太关心设备
此时尝试进行 I/O 操作，或者不进行。I/O 操作将失败并返回
读取时返回0xff的值，写入操作将被丢弃。如果超过
在适配器冻结时，会尝试对 EEH_MAX_FAILS 进行 I/O 操作，触发 EEH
假设设备驱动程序已进入无限循环
并打印错误到syslog。然后需要重新启动系统
让设备重新正常工作。

第2步：启用MMIO
---------------
平台重新启用对设备的MMIO（但通常不会启用
DMA），然后在所有受影响的设备上调用 mmio_enabled() 回调函数
设备驱动程序。

这是“早期恢复”调用。IO操作被再次允许，但DMA仍处于禁用状态。
不，有一些限制。这不是驱动程序的回调函数
重新开始操作，仅用于窥探/写入设备，提取诊断信息
信息（如有），并最终执行诸如触发设备本地操作之类的任务
重置或类似操作，但不是重新启动操作。如果发生这种情况，将调用此回调函数。
同一链路上的所有驱动程序都同意，它们可以尝试恢复，且没有自动
链路重置由硬件执行。如果平台无法直接重新启用IO
如果不进行插槽重置或链接重置，将不会调用此回调函数，且
而是会直接进入步骤3（链接重置）或步骤4（插槽重置）。

.. note::

在支持高级错误报告（PCIe r7.0 第6.2节）的平台上，
故障设备可能在步骤1（通知）中已经可以访问。
驱动程序仍应推迟对步骤2（MMIO已启用）的访问
与 powerpc 上的 EEH 以及 s390（设备所在的位置）兼容
无法访问，直到第二步。

在支持下游端口 containment 的平台上，到该链接的
发生故障的设备所在的子层级在步骤3中重新启用（链接
重置）。因此，子层级中的设备将无法访问，直到
步骤4（插槽重置）。

对于诸如 Surprise Down（PCIe r7.0 第 6.2.7 节）之类的错误，设备
在步骤4（插槽重置）中甚至可能无法访问。驱动程序可以检测
通过检查从设备读取的数据是否全为1来判断其可访问性
(PCI_POSSIBLE_ERROR())。

.. note::

以下是提议的内容；目前尚无平台实现此功能：
提案：所有 I/O 操作都应从内部_同步_进行
此回调，它们触发的错误将通过该回调返回
正常的 pci_check_whatever() API，无需新的 error_detected()
由于此处发生错误，将触发回调。
这样的错误可能导致IO被重新阻塞整个
段，从而使其他设备的恢复失效
同一网段上的其他设备可能已经执行的操作，迫使整个网段
进入下一个状态之一，即链路重置或插槽重置。

驱动程序应返回以下结果代码之一：
- PCI_ERS_RESULT_RECOVERED
驱动程序在认为设备已完全就绪时返回此值
功能正常，认为已准备好开始
正常的驱动程序操作再次。没有
确保驱动程序实际上会
允许继续前进，因为另一位驾驶员也正在
同一段可能已失败，从而触发了
在支持的平台上重置插槽。

- PCI_ERS_RESULT_NEED_RESET
驱动程序在认为设备不存在时返回此值
在其当前状态下可恢复，但需要一个插槽
重置以继续。

- PCI_ERS_RESULT_DISCONNECT
与上述相同。完全失败，即使在之后也无法恢复
重置驱动程序已失效。（需更精确地定义）

下一步操作取决于驱动程序返回的结果。
如果所有驱动程序都返回 PCI_ERS_RESULT_RECOVERED，那么该平台
继续执行步骤3（链路重置）或步骤5（恢复操作）。

如果任何驱动程序返回 PCI_ERS_RESULT_NEED_RESET，则平台
进入步骤4（槽位重置）

步骤3：链接重置
---------------
平台会重置该链接。这是PCIe特有的步骤
并且在检测到可导致致命错误时执行
通过重置链接“解决”。

STEP 4: 插槽重置
----------------

作为对返回值 PCI_ERS_RESULT_NEED_RESET 的响应，
平台将对请求的PCI设备执行插槽重置。
平台执行插槽重置所采取的实际步骤
将取决于平台。槽位重置完成后，
平台将调用设备的 slot_reset() 回调函数。

Powerpc 平台实现了两个级别的插槽重置：
软重置（默认）和基础重置（可选）。

Powerpc 软件重置包括断言适配器的 #RST 信号线，然后
恢复 PCI BAR 和 PCI 配置头到一个“干净”的状态，以避免残留状态引发死锁或数据损坏
这相当于一个全新系统下的情况
开机后紧随其后的是BIOS/系统固件初始化。
软重置也称为热重置。

仅 PCIe 卡支持 Powerpc 基本重置（Fundamental Reset）
并导致设备的状态机、硬件逻辑、端口状态以及寄存器被复位至默认值
配置寄存器以初始化为其默认状态。

对于大多数PCI设备，软重置足以实现恢复。
可选的基本重置功能可用于支持有限数量的
PCIe 设备中仅靠软重置不足以解决问题的情况
用于恢复。

如果平台支持PCI热插拔，那么重置可能会
通过切换插槽电源的关闭/开启来执行。

平台恢复PCI配置空间非常重要
进入“全新开机”状态，而非“上次状态”。之后
插槽重置后，设备驱动程序几乎总是会使用其标准
设备初始化例程，以及一种不寻常的配置空间设置
可能导致设备挂起、内核崩溃或静默数据损坏。

此调用使驱动程序有机会重新初始化硬件
（重新下载固件等）。此时，驱动程序可以假设
确保卡片处于全新状态且功能完好。插槽
处于未冻结状态，且驱动程序可以完全访问PCI配置空间，
内存映射I/O空间和DMA。中断（传统、MSI或MSI-X）
也将提供。

驱动程序不应重新开始正常的 I/O 处理操作
此时。如果所有设备驱动程序在此处报告成功
回调时，平台将调用 resume() 来完成该序列。
并让驱动程序重新开始正常的I/O处理。

如果驱动程序仍可能为此函数返回严重故障
重置后无法使设备进入正常运行状态。如果平台
之前尝试过软重置，现在可能会尝试硬重置（断电）
循环），然后再次调用 slot_reset()。如果设备仍然无法
可以恢复，就无法再进行其他操作；该平台
在此类情况下，通常会报告“永久性失败”。
设备在此情况下将被视为“已失效”。

多功能卡的驱动程序需要在各功能之间进行协调
它们自身无法确定哪个驱动实例将执行任何“一次性”操作
或全局设备初始化。例如，Symbios sym53cxx2
驱动程序仅从PCI功能0执行设备初始化：

	+       if (PCI_FUNC(pdev->devfn) == 0)
	+               sym_reset_scsi_bus(np, 0);

结果代码：
- PCI_ERS_RESULT_DISCONNECT
同上。

需要基本重置的 PCIe 卡驱动程序必须
在其 probe 函数中设置 `pci_dev` 结构体中的 `needs_freset` 位。
例如，QLogic qla2xxx 驱动程序会为某些情况设置 needs_freset 位
PCI 卡类型::

	+	/* Set EEH reset type to fundamental if required by hba  */
	+	if (IS_QLA24XX(ha) || IS_QLA25XX(ha) || IS_QLA81XX(ha))
	+		pdev->needs_freset = 1;
	+

平台继续执行步骤5（恢复运营）或步骤6（永久）
失败）。

.. note::

当前的 PowerPC 实现不会尝试进行电源循环
如果驱动程序返回 PCI_ERS_RESULT_DISCONNECT，则重置。
然而，它可能本应如此。


STEP 5: 恢复操作
----------------
平台将调用所有受影响设备的 resume() 回调
如果该路段的所有司机都已返回
PCI_ERS_RESULT_RECOVERED 来自之前的 3 个回调之一。
此回调的目标是通知驱动程序重新启动活动。
一切已恢复并正常运行。此回调不返回任何内容
一个结果代码。

此时，如果发生新的错误，平台将重新启动
一种新的错误恢复序列。

STEP 6: 永久性故障
------------------
发生了“永久性故障”，平台无法恢复
设备。平台将调用 error_detected() 并传入一个
pci_channel_io_perm_failure 的 pci_channel_state_t 值。

此时，设备驱动程序应假设最坏的情况。它应该
取消所有待处理的 I/O，拒绝所有新的 I/O，返回 -EIO 给
较高层。设备驱动程序应清理其所有
内存并从内核操作中移除自身，就像它原本应该做的那样
系统关闭期间。

平台通常会向系统操作员发出通知
以某种方式发生永久性故障。如果设备支持热插拔，
操作员可能需要拆卸并更换该设备。
但请注意，并非所有故障都是真正的“永久性”故障。有些是
由于过热引起，一些是由于插卡接触不良所致。许多
PCI错误事件由软件缺陷引起，例如DMA操作到
由于编程错误导致的非法地址访问或虚假的拆分事务（如由过热、接触不良或软件 bug 引起，并非所有情况都不可逆）
错误。请参阅 `Documentation/arch/powerpc/eeh-pci-error-recovery.rst` 中的讨论
关于实际场景中导致此类错误原因的更多详细信息
软件错误。


结论；一般说明
--------------
回调函数的调用方式由平台策略决定。一个平台
没有插槽重置功能，可能只想“忽略”那些无法支持的驱动程序
恢复（断开连接）并尝试让同一网段上的其他网卡工作
恢复。但请记住，在大多数现实情况下，会
每个片段只能有一个驱动程序。

现在，关于中断的一点说明。如果你收到一个中断信号并且你的
设备已死或已被隔离，出现问题 :)
当前政策是将此变为平台政策。
也就是说，恢复API仅要求：

- 不能保证中断传递可以从任何情况下继续进行
网段上从错误检测开始到
slot_reset 回调被调用时，应产生中断
完全投入运行。

- 不能保证中断传递已被停止，也就是说，
在检测到错误后收到中断的驱动程序，或检测到错误的驱动程序
中断处理程序中的一个错误，导致其无法正常工作
中断的确认（从而移除源）应该只是
返回 IRQ_NOTHANDLED。由平台来处理这种情况
条件，通常通过在持续期间屏蔽IRQ源来实现
错误处理。平台应“知道”哪个
中断被路由到具备错误管理能力的插槽并可进行处理
在错误处理期间临时禁用该IRQ编号（这
并不十分复杂）。这意味着其他设备会有一些IRQ延迟
共享中断，但除此之外别无他法。高端
平台不应在多个设备之间共享中断
不管怎样 :)

.. note::

powerpc 平台的实现细节在以下内容中讨论
文件 Documentation/arch/powerpc/eeh-pci-error-recovery.rst

截至目前，具有以下特性的设备驱动程序列表正在不断增加：
实现错误恢复的补丁。并非所有这些补丁都包含在其中
主线尚未确定。这些可以作为“示例”使用：

- drivers/scsi/ipr
- drivers/scsi/sym53c8xx_2
- drivers/scsi/qla2xxx
- drivers/scsi/lpfc
- drivers/next/bnx2.c
- drivers/next/e100.c
- drivers/net/e1000
- drivers/net/e1000e
- drivers/net/ixgbe
- drivers/net/cxgb3
- drivers/net/s2io.c

当在 handle_error_source() 中时，会调用 cor_error_detected() 回调函数
错误严重性为“可纠正”。回调是可选的，并允许
如有需要，可进行额外的日志记录。参见示例：

- drivers/cxl/pci.c

结尾
----


==================================================

由 Qwen-plus 及 LT agent 翻译