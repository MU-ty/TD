.. _up_doc:

翻译结果：

单处理器系统中的RCU
===================

一个常见的误解是，在单处理器系统（UP systems）上，call_rcu() 原语
可能立即调用其函数。这种误解的基础
因为只有一个CPU，所以应该没有必要
等待其他任何事情完成，因为没有其他CPU可供使用
还有其他事情正在发生。尽管这种方法会*有点*
尽管在相当多的情况下都有效，但通常来说这仍然是一个非常糟糕的主意。
本文档展示了三个示例，精确地说明了情况有多糟糕
这个主意不错。

示例1：软中断自杀
-----------------

假设一个基于RCU的算法扫描一个包含
过程上下文中的元素 A、B 和 C，并且可以从其中删除元素
相同的列表在软中断（softirq）上下文中。假设进程上下文的扫描
在被软中断处理打断时，正在引用元素 B，
删除元素 B，然后调用 call_rcu() 来释放元素 B
经过一段宽限期后。

现在，如果 call_rcu() 直接调用其参数，那么在返回时
从软中断开始，列表扫描会发现自己引用了一个刚刚被释放的
元素B。这种情况会大大降低
你的内核。

如果从硬件中断中调用 call_rcu()，也可能出现同样的问题
中断处理程序。

示例2：函数调用致命错误
-----------------------

当然，人们可以避免前文示例中描述的自杀行为
通过让 call_rcu() 仅在被调用时直接调用其参数
来自进程上下文。然而，这也可能以类似的方式失败。

假设基于RCU的算法再次扫描一个包含以下内容的链表
过程上下文中的元素 A、B 和 C，但它调用了一个函数
在扫描每个元素时对其执行该函数。进一步假设此函数
从列表中删除元素B，然后将其传递给call_rcu()进行延迟处理
令人解脱。这可能有点 unconventional，但完全合法
RCU 的使用，因为 call_rcu() 必须等待一个宽限期结束。
因此，在这种情况下，允许 call_rcu() 立即调用
它的论点将导致其无法做出基本的保证
底层的RCU，即call_rcu()会将其参数的调用延迟到
所有当前正在执行的RCU读端临界区都已完成。

快速测验 #1：
为什么在这种情况下调用 synchronize_rcu() 是*不合法*的？

:ref:`快速测验答案 <answer_quick_quiz_up>`

示例3：死锁之死
---------------

假设在持有锁的同时调用了 call_rcu()，并且该
回调函数必须获取相同的锁。在这种情况下，如果
如果 call_rcu() 直接调用回调函数，结果将会是
即使此次调用来自后续的执行，也会导致自死锁
call_rcu() 调用将在一个完整的宽限期之后。

在某些情况下，可以重构代码以使其
call_rcu() 会在锁释放后才被调用。然而，
在某些情况下，这可能会显得非常难看：

1.	如果需要将多个项目传递给 call_rcu() 函数
同一临界区，那么代码就需要创建
一个列表，然后在获得锁后遍历该列表一次
已发布。

2. 在某些情况下，锁将跨越某个内核API被持有。
因此，将 call_rcu() 的调用延迟到锁释放之后
要求通过通用API向上传递数据项。
远比保证回调被调用要好得多
在不持有任何锁的情况下进行修改，比不得不修改这些API以允许
任意数据项，将通过它们向上传递。

如果 call_rcu() 直接调用回调函数，则会带来痛苦的锁定限制
或者需要进行API更改。

快速测验 #2:
RCU回调必须遵守哪些锁定限制？

:ref:`快速测验答案 <answer_quick_quiz_up>`

需要注意的是，用户空间的RCU实现确实*会*
允许 call_rcu() 直接调用回调函数，但仅在自这些回调被加入队列以来，完整的宽限期已经过去的情况下才允许。
自这些回调被加入队列以来，宽限期已过。这种情况出现在某些用户态 RCU 实现中，为满足性能或资源限制需求，在确保已过完整宽限期的前提下允许直接调用回调。
这种情况是因为某些用户空间环境受到极大限制，例如无法支持额外的线程或延迟较高的同步机制，因此需要在满足宽限期后立即执行回调以减少开销。
然而，编写用户空间RCU实现的人员被强烈建议
建议避免从 call_rcu() 中调用回调函数，从而获得
上述提到的死锁避免优势。

摘要
----

允许 call_rcu() 立即调用其参数会破坏 RCU，
即使在单处理器系统上也是如此。因此不要这样做！即使在单处理器系统上，RCU 回调可能在持有软中断上下文锁（softirq）或其他隐式锁的情况下被执行，若在其中获取普通自旋锁，极易引发死锁。
基础设施*必须*遵守宽限期，并*必须*从一个不持有任何锁的确定环境（如软中断底半部上下文）中调用回调函数，且在回调中应避免使用会隐式加锁的操作（如 kfree()）。
从一个已知的环境中，且未持有任何锁的情况下——通常是软中断或任务底半部（tasklet）上下文中——安全地执行回调。

请注意，synchronize_rcu() 在单处理器系统上立即返回是安全的，
包括在单处理器系统上运行的 PREEMPT SMP 内核配置；然而，在可抢占 RCU（preemptible RCU）环境下，由于任务可能被抢占导致宽限期无法可靠完成，因此 synchronize_rcu() 不能立即返回。

快速测验 #3：
为什么在运行于单处理器（UP）系统上的可抢占 RCU（preemptible RCU）环境下，synchronize_rcu() 不能立即返回？
可抢占的 RCU？

.. _answer_quick_quiz_up:

翻译结果：

快速测验#1的答案：
为什么在这种情况下调用 synchronize_rcu() 是*不合法*的？

因为调用函数正在扫描一个受RCU保护的链表
列表，因此位于RCU读端临界区内。
因此，被调用函数已在RCU内被调用
读端临界区，且不允许阻塞。

快速测验#2的答案：
RCU回调必须遵守哪些锁定限制？

在RCU回调中获取的任何锁都必须被获取
否则在其他地方使用自旋锁原语的 _bh 变体。
例如，如果“mylock”被RCU回调获取，那么
获取此锁的进程上下文必须使用某些内容
例如使用 spin_lock_bh() 来获取锁。请注意
也可以使用自旋锁的 _irq 变体，例如，
spin_lock_irqsave()。

如果进程上下文代码只是简单地使用 spin_lock()，
然后，由于RCU回调可能在软中断上下文中被调用，
回调可能会被从中断的软中断（softirq）调用
进程上下文临界区。这将导致
自锁。

这一限制可能看似多余，因为极少有RCU
回调函数直接获取锁。然而，大量的RCU
回调确实会*间接地*获取锁，例如通过
kfree() 原语。

快速测验 #3 的答案：
为什么在单处理器系统上运行可抢占 RCU 时，synchronize_rcu() 不能立即返回？
因为在可抢占 RCU 配置下，读端临界区可能被抢占而长时间延迟，使得无法保证所有正在进行的读操作已经结束。因此，即使在 UP 系统上，也必须等待实际的宽限期完成，不能像非抢占 RCU 那样在 PREEMPT SMP 构建中立即返回。

因为其他某些任务可能在执行中途被抢占了
RCU读端临界区。如果调用synchronize_rcu()
直接立即返回，会过早地发出信号
宽限期结束，这将令人感到十分意外和震惊
另一个线程重新开始运行时。


==================================================

由 Qwen-plus 及 LT agent 翻译