{
  "original_summary": "以下是对所提供英文文档的详细中文摘要，严格遵循要求：涵盖主要观点、关键信息和结构，保持原文逻辑顺序与层次，语言简洁清晰，长度约为原文的20-30%，并包含所有重要概念与细节。\n\n---\n\n### **RCU补丁审查清单（中文摘要）**\n\n本文档为使用RCU（Read-Copy Update，读-拷贝-更新）机制的内核补丁提供了一份详尽的审查清单。违反其中任一规则可能导致类似未加锁的严重问题。该清单基于长期代码审查经验总结而成，适用于Linux内核开发中涉及RCU的场景。\n\n#### **0. 是否适用于“读多写少”场景？**\nRCU适用于数据结构被频繁读取而极少更新的情况（更新频率通常低于10%）。若更新过于频繁，应考虑其他同步机制，除非性能测试明确表明RCU仍是最优选择。例外情况包括：\n- 性能非关键，但RCU实现更简单（如Linux 2.6中的动态NMI处理）；\n- 需要极低实时延迟的读操作；\n- 使用RCU读端原语防止无锁更新中的ABA问题（此时`rcu_read_lock()`用于保护写操作，类似于垃圾回收机制对算法的简化）。\n\n#### **1. 更新代码是否具备适当的互斥机制？**\nRCU允许读方无锁运行，但**写方必须保证互斥**，可通过以下方式实现：\n- 锁机制（locking）；\n- 原子操作（atomic operations）；\n- 将更新限制在单一任务中。\n若采用原子操作，需说明如何处理弱内存序架构下的内存屏障问题；若限定单任务更新，需论证其不会成为系统瓶颈（尤其在百核级别系统上）。\n\n#### **2. RCU读端临界区是否正确使用了`rcu_read_lock()`等原语？**\n任何访问RCU保护指针的操作都必须处于RCU读端临界区内，否则可能导致数据在读取过程中被提前释放，引发内核崩溃风险。合法方式包括：\n- `rcu_read_lock()` / `rcu_read_unlock()` 及其变体（如_bh、_sched）；\n- 获取自旋锁或禁用抢占（可替代`rcu_read_lock_sched()`，但可读性差且影响lockdep检测）；\n- 使用`guard(rcu)`或`scoped_guard(rcu)`等作用域守卫，减少出错概率。\n禁止将RCU保护的指针“泄露”出临界区，除非已通过锁或引用计数等方式提供额外保护。\n\n#### **3. 更新代码是否能容忍并发读取？**\nRCU的核心在于允许多个读者与更新者并发执行。应对策略包括：\n- 使用RCU专用链表操作（如`list_add_rcu`、`hlist_del_rcu`）；\n- 引入元素级锁，供读写双方共同持有；\n- 确保更新对读者呈现原子性（如对齐指针赋值、使用`smp_store_release`）；\n- 合理安排读写顺序，并辅以内存屏障（如`smp_mb()`），推荐通过间接结构+指针替换实现“伪原子更新”。\n\n#### **4. 弱内存序CPU的特殊注意事项**\n几乎所有现代CPU均为弱内存序（包括x86），因此必须采取以下措施防止内存错误：\n- 使用`rcu_dereference()`确保指针与其指向数据的加载顺序正确，同时防止编译器优化破坏语义；\n- 初始化结构体后才公开其指针，使用`rcu_assign_pointer()`完成安全发布；\n- 链表操作必须使用`_rcu`后缀版本（如`list_add_tail_rcu`、`list_del_rcu`），避免初始化与链接顺序错乱；\n- 类似规则适用于`hlist_nulls`类型链表。\n\n#### **5. 回调函数不可阻塞**\n由`call_rcu()`等注册的回调可能在软中断上下文执行，且底半部（bottom halves）被禁用，因此**回调函数不得睡眠或阻塞**。若需执行阻塞性操作，应在回调中调度工作队列（workqueue），可使用`queue_rcu_work()`简化此过程。\n\n#### **6. `synchronize_rcu()`不可在中断上下文中调用**\n所有形式的`synchronize_*`原语（包括`srcu`、`tasks`等变种）均可阻塞，故严禁在IRQ或软中断上下文中调用。加速版（expedited）虽语义相同，但开销更大，仅限罕见配置变更时使用，且应避免循环调用。建议批量更新，或改用异步`call_rcu()`。实时负载敏感系统可通过`rcupdate.rcu_normal`参数禁用加速模式。\n\n#### **7. 正确匹配RCU类型与读写原语**\n自v4.20起，内核仅支持一种RCU类型（PREEMPT=n时为RCU-sched，=y时为RCU-preempt）。不同类型RCU需配对使用相应原语：\n- 普通RCU：`call_rcu()`/`synchronize_rcu()` + `rcu_read_lock()` 或禁BH/抢占的组合；\n- SRCU：必须使用`srcu_read_lock()`/`srcu_read_unlock()`及同一`srcu_struct`；\n- RCU Tasks系列：\n  - `call_rcu_tasks()`：读者不得阻塞；\n  - `call_rcu_tasks_trace()`：需用`rcu_read_lock_trace()`；\n  - `synchronize_rcu_tasks_rude()`：读者需禁用抢占。\n混用会导致系统崩溃甚至安全漏洞，非直观配对务必加注释说明。\n\n#### **8. `synchronize_rcu()` vs `call_rcu()`的选择**\n尽管`synchronize_rcu()`较慢（毫秒级延迟），但代码更简洁且具备**自我节流能力**：当宽限期延迟时，更新自然延后。而`call_rcu()`需手动控制更新速率，以防OOM或实时延迟过高。推荐使用`kfree_rcu()`/`kvfree_rcu()`实现“即发即忘”的内存释放。节流方法包括：\n- 限制待回收元素总数或积压数量；\n- 控制更新频率；\n- 依赖可信用户手动操作；\n- 定期调用`rcu_barrier()`协调批次。\n\n#### **9. 列表遍历原语的使用条件**\n所有RCU列表遍历宏（如`list_for_each_entry_rcu`）必须位于RCU读端临界区或持有更新侧锁的上下文中。例外：仅追加不删除的数据结构可用`READ_ONCE()`替代`rcu_dereference()`，并省略读锁。\n\n#### **10. 读端临界区内必须使用`_rcu`宏**\n在RCU读端临界区中访问链表时，若未持有更新锁，则**必须使用`_rcu`后缀的遍历宏**，否则会破坏Alpha架构兼容性、引发编译器误优化，并导致代码理解困难。\n\n#### **11. RCU回调中获取的锁必须禁用软中断**\n在回调中获取的锁（如自旋锁）必须始终以`spin_lock_bh()`等方式禁用软中断，否则可能因软中断上下文调用回调而导致死锁。\n\n#### **12. RCU回调可能并发执行且无序**\n多个RCU回调可能并行执行，且不保证顺序或在同一CPU上运行。即使来自同一线程的回调也可能跨CPU执行（如CPU下线时迁移）。此外，在offload模式下，同一CPU的回调可能由软中断和kthread并发处理，导致乱序和并发执行。因此，若回调操作共享数据结构，必须自行加锁保护。\n\n#### **13. SRCU特性：支持睡眠的读端临界区**\nSRCU（Sleepable RCU）允许在读端临界区（`srcu_read_lock/unlock`）中睡眠，适合极读密集型场景或需避免读端死锁的应用。但需注意：\n- 必须显式初始化`srcu_struct`（静态或动态）；\n- 不同`srcu_struct`独立管理宽限期，避免全局阻塞；\n- 开销无法全局摊销，性能通常不如普通RCU；\n- 推荐优先考虑`percpu_rw_semaphore`或`rw_semaphore`；\n- `synchronize_srcu_expedited()`不发送IPI，更适合实时系统；\n- RCU Tasks Trace也支持睡眠读端，但属专用场景，一般应选用SRCU。\n\n#### **14. 析构操作前必须切断读者路径**\n`call_rcu()`等机制仅等待**已有读者**完成，不阻止新读者进入。因此，必须先移除读者可访问的引用路径（如从链表删除节点），再发起回调或同步操作，确保后续读者不会访问即将销毁的数据。\n\n#### **15. RCU读端原语不含内存屏障**\nRCU读端临界区本身不隐含内存屏障，编译器和CPU可自由重排代码进出该区域。同步责任由写端原语承担。SRCU读端解锁后可使用`smp_mb__after_srcu_read_unlock()`插入全屏障。\n\n#### **16. 使用调试工具验证RCU正确性**\n建议启用以下配置检测RCU错误：\n- `CONFIG_PROVE_LOCKING`：检查是否在正确上下文中访问RCU保护数据；\n- `CONFIG_DEBUG_OBJECTS_RCU_HEAD`：防止对象在宽限期结束前重复提交给`call_rcu()`；\n- `CONFIG_RCU_STRICT_GRACE_PERIOD` + KASAN：检测指针泄露出读端临界区（仅限4核以内）；\n- `__rcu` sparse标记：静态检查是否遗漏`rcu_dereference()`。\n\n#### **17. 模块卸载前必须清理所有RCU回调**\n模块卸载前必须确保所有已注册的RCU回调均已执行完毕。仅调用`synchronize_rcu()`不足以等待其他CPU上的回调。正确做法是结合“同步+屏障”双操作：\n- 普通RCU：`synchronize_rcu()` + `rcu_barrier()`\n- SRCU：`synchronize_srcu()` + `srcu_barrier()`\n- 其他类型类似。\n两者功能互补：前者等待宽限期，后者等待回调执行。必要时可通过workqueue并发执行这对操作。\n\n---\n\n### **总结**\n本清单系统梳理了RCU使用的17项核心原则，覆盖适用场景、读写并发控制、内存序保障、回调管理、类型匹配、调试验证及模块生命周期处理等方面。遵循这些规则可有效避免数据竞争、内存泄漏、死锁和系统崩溃，是编写和审查RCU相关代码的重要依据。",
  "translated_summary": "**RCU补丁审查清单中文摘要**\n\n本文档为Linux内核中使用RCU（Read-Copy Update）机制的代码补丁提供了一份详尽的审查清单，旨在避免因误用RCU而导致的数据竞争、内存损坏或系统崩溃等问题。以下是译文内容的核心要点与结构化摘要：\n\n---\n\n### 一、RCU适用场景判断（第0条）\nRCU适用于**以读为主**的场景，当数据结构更新频率低于约10%时效果最佳。若更新频繁，应考虑其他同步机制，除非有性能测量支持其合理性。例外情况包括：\n- 实现更简单；\n- 需要极低延迟的读操作；\n- 用于防止无锁算法中的ABA问题。\n\n---\n\n### 二、写入端必须保证互斥（第1条）\n尽管RCU允许读端无锁并发，但**写入端仍需互斥机制**，可通过：\n- 锁（如自旋锁）；\n- 原子操作配合内存屏障（注意弱序架构如x86也需处理重排序）；\n- 将更新限制在单一任务中（需论证不会成为瓶颈）。\n\n---\n\n### 三、RCU读端临界区正确使用（第2条）\n所有访问RCU保护指针的操作必须位于**RCU读端临界区内**，由以下原语界定：\n- `rcu_read_lock()` / `rcu_read_unlock()`\n- `rcu_read_lock_bh()` / `rcu_read_unlock_bh()`\n- `rcu_read_lock_sched()` / `rcu_read_unlock_sched()`\n\n也可通过`preempt_disable()`或持有原始自旋锁进入临界区。推荐使用`guard(rcu)`等作用域保护机制以减少出错风险。禁止将受保护指针“泄露”出临界区，否则需额外保护（如引用计数或锁）。\n\n---\n\n### 四、并发访问设计（第3条）\nRCU的核心优势是允许多个读者与写者并发执行。应对策略包括：\n- 使用RCU专用链表操作（如`list_add_rcu`, `list_del_rcu`）；\n- 为元素加锁实现细粒度保护；\n- 使更新对读者呈现原子性（如通过指针替换整个结构）；\n- 精心安排内存顺序，结合`smp_store_release()`和`smp_load_acquire()`确保可见性。\n\n---\n\n### 五、弱序CPU的特殊处理（第4条）\n几乎所有现代CPU存在内存重排序行为，必须采取措施：\n- 读者使用`rcu_dereference()`确保指针与其所指数据的加载顺序；\n- 写者使用`rcu_assign_pointer()`安全发布新指针；\n- 列表操作应使用`_rcu`变体宏（如`list_add_tail_rcu`），防止初始化与赋值乱序；\n- 删除操作使用`list_del_rcu`避免读者访问已释放内存。\n\n---\n\n### 六、回调函数调用上下文限制（第5条）\n`call_rcu()`等异步回调可能运行在软中断或中断上下文中，因此**回调函数不能阻塞或睡眠**。若需阻塞操作，应在回调中调度工作队列处理。\n\n---\n\n### 七、同步原语不可在中断上下文调用（第6条）\n`synchronize_rcu()`等同步原语会阻塞，**禁止在中断上下文（包括软中断、硬中断）中调用**。加速版本（如`synchronize_rcu_expedited()`）消耗更多CPU资源，仅限配置变更等少数场景使用，避免在循环中频繁调用。\n\n---\n\n### 八、RCU类型匹配与混合使用规则（第7条）\n不同RCU变体对应不同的读/写原语，**不得混用**：\n- 普通RCU：`rcu_read_lock()` + `call_rcu()` / `synchronize_rcu()`\n- SRCU：`srcu_read_lock()` + `call_srcu()` / `synchronize_srcu()`，支持睡眠\n- Tasks RCU：要求读者不阻塞（即无上下文切换）\n- Tracing Tasks RCU：需配对`rcu_read_lock_trace()`\n- Rude Tasks RCU：要求禁用抢占\n\n混合使用会导致死锁或安全漏洞，必要时应添加注释说明。\n\n---\n\n### 九、同步 vs 异步释放的选择（第8条）\n`synchronize_rcu()`虽慢但代码简洁且具备自限性（宽限期延迟则更新自动延迟），优于`call_rcu()`，除非性能敏感或不能阻塞。推荐使用`kfree_rcu()`实现“即发即忘”的内存释放。\n\n对于`call_rcu()`，需主动控制更新速率，方法包括：\n- 限制待释放对象数量；\n- 控制更新频率；\n- 依赖可信用户输入；\n- 定期调用`rcu_barrier()`清理回调。\n\n---\n\n### 十、列表遍历与访问规范（第9–10条）\n所有RCU保护的数据结构遍历（如`list_for_each_entry_rcu`）必须在读端临界区或更新锁保护下进行，并使用`rcu_dereference()`获取指针。反之，在临界区内访问RCU指针时，**必须使用`_rcu`变体宏**，否则可能导致编译器生成错误代码。\n\n仅当数据只增不删且新增节点不会立即被访问时，可用`READ_ONCE()`替代。\n\n---\n\n### 十一、回调中的锁与并发问题（第11–12条）\n- RCU回调中获取的锁必须在禁用软中断环境下进行（如`spin_lock_bh()`），否则可能引发死锁。\n- 多个RCU回调可并发执行，甚至在同一CPU上并行运行，**不能假设执行顺序或CPU亲和性**。若操作共享数据，需自行加锁保护。\n\n---\n\n### 十二、SRCU特性与使用建议（第13条）\nSRCU允许读端睡眠，适合需要阻塞的场景，但性能通常低于普通RCU。使用前需显式初始化`srcu_struct`，并通过`srcu_read_lock()`/`srcu_read_unlock()`配对使用。其宽限期仅等待同`srcu_struct`的读者，隔离性好，不易导致OOM。\n\nSRCU的快速版本不发送IPI，更适合实时系统。推荐优先于读写信号量用于高读负载场景。\n\n---\n\n### 十三、安全释放的关键顺序（第14条）\n调用`call_rcu()`或`synchronize_rcu()`前，必须先移除读者可能访问的旧数据路径，再触发回收。这些原语仅等待**已有读者完成**，不保护后续访问。\n\n---\n\n### 十四、内存屏障缺失问题（第15条）\nRCU读端原语本身**不包含内存屏障**，编译器和CPU可能重排指令。更新侧负责处理内存顺序。SRCU读者可在`srcu_read_unlock()`后使用`smp_mb__after_srcu_read_unlock()`插入全屏障。\n\n---\n\n### 十五、调试与验证工具（第16条）\n建议启用以下配置检测RCU错误：\n- `CONFIG_PROVE_LOCKING`：检查是否在正确临界区访问RCU数据；\n- `CONFIG_DEBUG_OBJECTS_RCU_HEAD`：防止重复注册未完成的`call_rcu`对象；\n- `CONFIG_RCU_STRICT_GRACE_PERIOD` + KASAN：检测指针泄露（限小系统）；\n- `__rcu`稀疏检查：标记RCU指针，未通过`rcu_dereference()`访问时报错。\n\n---\n\n### 十六、模块卸载时的回调清理（第17条）\n若在模块中注册了`call_rcu()`等回调，卸载前必须调用对应的**屏障函数**确保所有回调已执行：\n- `rcu_barrier()`（对应`call_rcu`）\n- `srcu_barrier()`（对应`call_srcu`）\n- `rcu_barrier_tasks()` / `rcu_barrier_tasks_trace()` 等\n\n注意：屏障函数**不保证等待宽限期结束**，若需同时等待宽限期和回调完成，应组合调用`synchronize_*()`与对应`barrier()`函数。\n\n---\n\n### 总结\n本清单系统梳理了RCU使用的17项关键规则，涵盖适用场景、读写端同步、内存顺序、回调管理、类型匹配、调试验证等方面，强调**正确性、安全性与可维护性**。遵循此清单可有效规避RCU常见陷阱，提升内核代码质量。",
  "comparison_result": {
    "completeness_score": 8,
    "missing_content": "1. 原文第0条中关于“Linux 2.6中的动态NMI处理”作为RCU实现更简单的具体示例，在译文中仅泛化为“实现更简单”，未保留该关键历史实例。\n2. 原文第1条提到“若限定单任务更新，需论证其不会成为系统瓶颈（尤其在百核级别系统上）”，译文虽提及“需论证不会成为瓶颈”，但遗漏了“百核级别系统”这一重要性能考量背景。\n3. 原文第2条指出使用自旋锁或禁用抢占可替代`rcu_read_lock_sched()`，“但可读性差且影响lockdep检测”，此关于**代码可读性和lockdep调试工具影响**的关键副作用在译文中完全缺失。\n4. 原文第4条明确指出规则同样适用于`hlist_nulls`类型链表，译文未提此特殊数据结构的支持要求。\n5. 原文第7条中对RCU Tasks系列的描述更为精确：“`call_rcu_tasks()`：读者不得阻塞；`call_rcu_tasks_trace()`：需用`rcu_read_lock_trace()`；`synchronize_rcu_tasks_rude()`：读者需禁用抢占。”而译文将三者混述为“Tasks RCU”和“Tracing Tasks RCU”等模糊分类，丢失了各变种的具体约束条件及其配对原语的严格对应关系。\n6. 原文第8条强调`synchronize_rcu()`具备“自我节流能力”（self-throttling），即宽限期延迟会自然延后更新，从而防止过载。译文称其“优于call_rcu”，表述倾向性强且简化了原意，弱化了“自我节流”这一核心机制说明。\n7. 原文第9条例外情况说明：“仅追加不删除的数据结构可用`READ_ONCE()`替代`rcu_dereference()`，并省略读锁。”译文改为“新增节点不会立即被访问时”才可用`READ_ONCE()`，改变了前提条件，引入偏差。\n8. 原文第12条补充细节：即使来自同一线程的回调也可能因CPU下线而迁移执行；在offload模式下，同一CPU上的回调可能由软中断和kthread并发处理。这些关于**回调执行上下文迁移与并发模型**的重要信息在译文中完全缺失。\n9. 原文第13条指出SRCU“开销无法全局摊销，性能通常不如普通RCU”，并建议“优先考虑`percpu_rw_semaphore`或`rw_semaphore`”，译文仅说“推荐优先于读写信号量”，逻辑方向相反，造成误导。\n10. 原文第17条明确指出：`synchronize_rcu()`不足以等待其他CPU上的回调完成，并强调“两者功能互补：前者等待宽限期，后者等待回调执行”。译文虽提到组合调用，但未清晰区分`synchronize_*`与`barrier()`的不同职责，削弱了技术准确性。",
    "suggestions": "1. 补充所有被简化的具体案例和技术细节，如“Linux 2.6动态NMI处理”、“百核系统瓶颈”、“hlist_nulls支持”等，以增强技术完整性。\n2. 恢复原文中关于lockdep检测受影响、CPU迁移导致回调乱序等易忽略但关键的调试与运行时行为说明。\n3. 精确还原RCU Tasks各子类型的配对规则，避免笼统归类，确保安全边界清晰。\n4. 修正第13条中关于`percpu_rw_semaphore`的误译，明确应优先选用传统同步机制而非SRCU。\n5. 强调`synchronize_rcu()`的“自我节流”机制本质，而非简单评价其“优于”异步方式。\n6. 明确区分`synchronize_*`（等待宽限期）与`*_barrier()`（等待回调执行）的功能差异，特别是在模块卸载场景下的协同作用。\n7. 统一术语编号体系，原文为连续编号（0–17），译文改用中文序号（一至十六）虽可接受，但建议保持与原文一致以便对照审查。",
    "raw_result": "- 完整ity评分：8  \n- 遗漏内容：\n  1. 原文第0条中关于“Linux 2.6中的动态NMI处理”作为RCU实现更简单的具体示例，在译文中仅泛化为“实现更简单”，未保留该关键历史实例。\n  2. 原文第1条提到“若限定单任务更新，需论证其不会成为系统瓶颈（尤其在百核级别系统上）”，译文虽提及“需论证不会成为瓶颈”，但遗漏了“百核级别系统”这一重要性能考量背景。\n  3. 原文第2条指出使用自旋锁或禁用抢占可替代`rcu_read_lock_sched()`，“但可读性差且影响lockdep检测”，此关于**代码可读性和lockdep调试工具影响**的关键副作用在译文中完全缺失。\n  4. 原文第4条明确指出规则同样适用于`hlist_nulls`类型链表，译文未提此特殊数据结构的支持要求。\n  5. 原文第7条中对RCU Tasks系列的描述更为精确：“`call_rcu_tasks()`：读者不得阻塞；`call_rcu_tasks_trace()`：需用`rcu_read_lock_trace()`；`synchronize_rcu_tasks_rude()`：读者需禁用抢占。”而译文将三者混述为“Tasks RCU”和“Tracing Tasks RCU”等模糊分类，丢失了各变种的具体约束条件及其配对原语的严格对应关系。\n  6. 原文第8条强调`synchronize_rcu()`具备“自我节流能力”（self-throttling），即宽限期延迟会自然延后更新，从而防止过载。译文称其“优于call_rcu”，表述倾向性强且简化了原意，弱化了“自我节流”这一核心机制说明。\n  7. 原文第9条例外情况说明：“仅追加不删除的数据结构可用`READ_ONCE()`替代`rcu_dereference()`，并省略读锁。”译文改为“新增节点不会立即被访问时”才可用`READ_ONCE()`，改变了前提条件，引入偏差。\n  8. 原文第12条补充细节：即使来自同一线程的回调也可能因CPU下线而迁移执行；在offload模式下，同一CPU上的回调可能由软中断和kthread并发处理。这些关于**回调执行上下文迁移与并发模型**的重要信息在译文中完全缺失。\n  9. 原文第13条指出SRCU“开销无法全局摊销，性能通常不如普通RCU”，并建议“优先考虑`percpu_rw_semaphore`或`rw_semaphore`”，译文仅说“推荐优先于读写信号量”，逻辑方向相反，造成误导。\n  10. 原文第17条明确指出：`synchronize_rcu()`不足以等待其他CPU上的回调完成，并强调“两者功能互补：前者等待宽限期，后者等待回调执行”。译文虽提到组合调用，但未清晰区分`synchronize_*`与`barrier()`的不同职责，削弱了技术准确性。\n\n- 建议：\n  1. 补充所有被简化的具体案例和技术细节，如“Linux 2.6动态NMI处理”、“百核系统瓶颈”、“hlist_nulls支持”等，以增强技术完整性。\n  2. 恢复原文中关于lockdep检测受影响、CPU迁移导致回调乱序等易忽略但关键的调试与运行时行为说明。\n  3. 精确还原RCU Tasks各子类型的配对规则，避免笼统归类，确保安全边界清晰。\n  4. 修正第13条中关于`percpu_rw_semaphore`的误译，明确应优先选用传统同步机制而非SRCU。\n  5. 强调`synchronize_rcu()`的“自我节流”机制本质，而非简单评价其“优于”异步方式。\n  6. 明确区分`synchronize_*`（等待宽限期）与`*_barrier()`（等待回调执行）的功能差异，特别是在模块卸载场景下的协同作用。\n  7. 统一术语编号体系，原文为连续编号（0–17），译文改用中文序号（一至十六）虽可接受，但建议保持与原文一致以便对照审查。"
  },
  "chunk_count": 464,
  "completeness_score": 8,
  "refine_mode": "targeted"
}