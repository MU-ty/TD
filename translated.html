<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- 展示仓库结构的交互逻辑 -->
  <script>
    (function() {
      function setOpenState(dirEl, open) {
        const children = dirEl.querySelector(':scope > .children');
        const toggle = dirEl.querySelector(':scope > .node .toggle');
        if (!children || !toggle) return;
        if (open) {
          children.classList.remove('hidden');
          toggle.textContent = '▼';
        } else {
          children.classList.add('hidden');
          toggle.textContent = '▶';
        }
      }

      // 点击目录行展开/折叠
      document.querySelectorAll('#tree .dir > .node').forEach(node => {
        node.addEventListener('click', (e) => {
          const dir = node.parentElement;
          const children = dir.querySelector(':scope > .children');
          if (!children) return;
          const isHidden = children.classList.contains('hidden');
          setOpenState(dir, isHidden);
          e.stopPropagation();
        });
      });

      // 展开/折叠全部
      const expandAll = document.getElementById('expandAll');
      const collapseAll = document.getElementById('collapseAll');
      expandAll.addEventListener('click', () => {
        document.querySelectorAll('#tree .dir').forEach(d => setOpenState(d, true));
      });
      collapseAll.addEventListener('click', () => {
        document.querySelectorAll('#tree .dir').forEach(d => setOpenState(d, false));
      });

      // 搜索过滤
      const search = document.getElementById('search');
      const treeRoot = document.getElementById('tree');
      function applyFilter() {
        const q = search.value.trim().toLowerCase();
        // 重置可见性
        treeRoot.querySelectorAll('li').forEach(li => li.classList.remove('hidden'));
        if (!q) {
          document.querySelectorAll('#tree .dir').forEach(d => setOpenState(d, false));
          return;
        }
        // 隐藏不匹配项
        treeRoot.querySelectorAll('li').forEach(li => {
          const text = li.innerText.toLowerCase();
          if (!text.includes(q)) li.classList.add('hidden');
        });
        // 展开以便可见
        document.querySelectorAll('#tree .dir').forEach(d => setOpenState(d, true));
      }
      search.addEventListener('input', applyFilter);

      // 返回顶部按钮
      const back = document.getElementById('backtop');
      window.addEventListener('scroll', () => {
        back.style.display = window.scrollY > 600 ? 'block' : 'none';
      });
      back.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
    })();
  </script>
其源代码。


==================================================

由 Qwen-plus 及 LT agent 翻译</script>
  <script type="text/plain" id="content-tph">.. SPDX-License-Identifier: GPL-2.0



TPH 支持
========

:Copyright: 2024 Advanced Micro Devices, Inc.
:作者: - Eric van Tassell &lt;eric.vantassell@amd.com&gt;
- Wei Huang &lt;wei.huang2@amd.com&gt;


概述
====

TPH（TLP 处理提示）是一种 PCIe 功能，允许端点设备
为针对内存空间的请求提供优化提示。
这些提示以一种称为转向标签（STs）的格式嵌入到
请求者的TLP头，使系统硬件（如根端口）能够
复杂，以便更好地管理这些请求的平台资源。

例如，在采用基于TPH的直接数据缓存注入的平台上
支持，终端设备可以在其DMA中包含适当的ST
流量以指定数据应写入哪个缓存。这允许
CPU核心有更高的概率从缓存中获取数据，
可能提升性能并降低数据延迟
正在处理。


如何使用TPH
===========

TPH 被作为 PCIe 中的一项可选扩展功能提出。Linux
内核在系统启动时负责完成TPH能力的发现（capability discovery），但是否启用由设备驱动决定。
驱动程序在需要使用时应请求启用TPH。一旦启用，
驱动程序使用提供的 API 获取目标内存的转向标签（Steering Tag），
并将ST编程到设备的ST表中。

在 Linux 中启用 TPH 支持
------------------------

要支持TPH，内核必须使用CONFIG_PCIE_TPH选项进行构建
已启用。

管理TPH
-------

要为设备启用TPH，请使用以下函数：

int pcie_enable_tph(struct pci_dev *pdev, int mode);

此函数为具有特定ST模式的设备启用TPH支持。
当前支持的模式包括：

* PCI_TPH_ST_NS_MODE - 无 ST 模式
* PCI_TPH_ST_IV_MODE - 中断向量模式
* PCI_TPH_ST_DS_MODE - 设备特定模式

`pcie_enable_tph()` 检查请求的模式是否实际
在启用之前，设备必须支持。设备驱动程序可以自行确定
支持哪种TPH模式，并且可以根据情况正确启用
`pcie_enable_tph()` 的返回值。

要禁用TPH，请使用以下函数：

void pcie_disable_tph(struct pci_dev *pdev);

管理 ST
-------

Steering Tags 是特定于平台的。PCIe 规范未指定 STs 的位置
而是由PCI固件规范定义了一个ACPI _DSM方法
（参见 `Revised _DSM for Cache Locality TPH Features ECN
&lt;https://members.pcisig.com/wg/PCI-SIG/document/15470&gt;`_) 用于检索
针对具有各种属性的目标内存的STs。此方法是
在此实现中受支持。

要检索与特定目标内存关联的转向标签
CPU，使用以下函数：

int pcie_tph_get_cpu_st(struct pci_dev *pdev, enum tph_mem_type type,
unsigned int cpu_uid, u16 *tag);

`type` 参数用于指定内存类型，可以是易失性的
或持久性。`cpu_uid` 参数指定了目标内存的
与内存关联的CPU。

在获取ST值后，设备驱动程序可以使用以下内容
将ST写入设备的函数::

int pcie_tph_set_st_entry(struct pci_dev *pdev, unsigned int index,
u16 标签);

`index` 参数是 ST 标签将要使用的 ST 表项索引
写入。`pcie_tph_set_st_entry()` 将会确定合适的
ST表的位置，位于MSI-X表或TPH扩展中
能力空间，并将转向标签写入由指向的ST条目中
`index` 参数。

如何使用这些TPH函数完全由驱动程序自主决定。
例如，网络设备驱动程序可以使用上述TPH API
在RX/TX队列的中断亲和性发生变化时，通过附带的C语言代码示例展示如何同步更新Steering Tag。
been changed. 以下是一个 IRQ 亲和性通知器的示例代码：

.. code-block:: c

static void irq_affinity_notified(struct irq_affinity_notify *notify,
const cpumask_t *mask)
{
struct drv_irq *irq;
unsigned int cpu_id;
u16 标签;

irq = container_of(notify, struct drv_irq, affinity_notify);
cpumask_copy(irq->cpu_mask, mask);

/* 选择一个合适的CPU作为目标——这里只是一个示例 */
cpu_id = cpumask_first(irq->cpu_mask);

if (pcie_tph_get_cpu_st(irq->pdev, TPH_MEM_TYPE_VM, cpu_id,
&tag))
return;

if (pcie_tph_set_st_entry(irq->pdev, irq->msix_nr, tag))
return;
}

禁用 TPH 系统范围功能
---------------------

有一个内核命令行选项可用于控制TPH功能：
* "notph"：TPH 将对所有终端设备禁用。


==================================================

由 Qwen-plus 及 LT agent 翻译</script>

  <script>
    (function() {
      // 注入脚本文本到 <pre>
      const pres = document.querySelectorAll('pre[data-source]');
      pres.forEach(pre => {
        const id = pre.getAttribute('data-source');
        const src = document.getElementById(id);
        if (src) {
          pre.textContent = src.textContent.replaceAll('\r\n', '\n');
          // 将文本用于搜索（节级 data-content）
          const sec = pre.closest('section');
          if (sec) sec.dataset.content = pre.textContent.slice(0, 5000);
        }
      });

      // 目录高亮（滚动时） - 简化：不做复杂观察，保持静态

      // 复制按钮
      document.querySelectorAll('.btn.copy').forEach(btn => {
        btn.addEventListener('click', async () => {
          const targetId = btn.getAttribute('data-target');
          const pre = document.getElementById(targetId);
          if (!pre) return;
          try {
            await navigator.clipboard.writeText(pre.textContent);
            btn.textContent = '已复制';
            btn.style.borderColor = 'var(--ok)';
            setTimeout(() => { btn.textContent = '复制全文'; btn.style.borderColor = 'var(--border)'; }, 1500);
          } catch (e) {
            btn.textContent = '复制失败';
            btn.style.borderColor = 'var(--warn)';
            setTimeout(() => { btn.textContent = '复制全文'; btn.style.borderColor = 'var(--border)'; }, 1500);
          }
        });
      });

      // 展开/折叠全部
      const expandAll = document.getElementById('expandAll');
      const collapseAll = document.getElementById('collapseAll');
      expandAll.addEventListener('click', () => {
        document.querySelectorAll('section details').forEach(d => d.open = true);
      });
      collapseAll.addEventListener('click', () => {
        document.querySelectorAll('section details').forEach(d => d.open = false);
      });

      // 搜索过滤
      const search = document.getElementById('search');
      const sections = Array.from(document.querySelectorAll('main section.card'));
      function applyFilter() {
        const q = search.value.trim().toLowerCase();
        if (!q) { sections.forEach(s => s.classList.remove('hidden')); return; }
        sections.forEach(sec => {
          const hay = (sec.dataset.title || '') + ' ' + (sec.dataset.content || '');
          if (hay.toLowerCase().includes(q)) sec.classList.remove('hidden');
          else sec.classList.add('hidden');
        });
      }
      search.addEventListener('input', applyFilter);

      // 返回顶部按钮
      const back = document.getElementById('backtop');
      window.addEventListener('scroll', () => {
        back.style.display = window.scrollY > 600 ? 'block' : 'none';
      });
      back.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
    })();
  </script>
</body>
</html>
