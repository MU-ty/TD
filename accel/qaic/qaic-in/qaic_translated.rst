.. SPDX-License-Identifier: GPL-2.0-only


QAIC 驱动程序
=============

QAIC驱动程序是AIC100系列AI的内核模式驱动程序（KMD）
加速器产品。

中断
====

IRQ风暴缓解
-----------

尽管AIC100 DMA桥接硬件实现了IRQ风暴缓解机制
机制，仍然可能发生IRQ风暴。风暴可能在
如果工作负载特别轻，且主机响应迅速。如果主机
可以像设备向其中插入元素一样快地清空响应FIFO
它，那么设备将频繁地使响应FIFO从空状态转换为
非空且生成MSI的速率相当于
工作负载处理输入的能力。lprnet（车牌识别网络）
已知工作负载会触发此条件，并可能产生超过100k的量
每秒百万条指令（MSIs）。据观察，大多数系统无法承受这种水平
时间一长就会因为某种看门狗机制而崩溃，这是由于开销所致
中断控制器向主机CPU发出中断。

为缓解此问题，QAIC驱动程序实现了特定的IRQ处理。当
QAIC 接收到一个中断请求（IRQ）后，会禁用该线路。这可以防止中断
控制器从中断CPU。然后AIC清空FIFO。一旦FIFO
已耗尽，QAIC 会实施一种“最后机会”轮询算法，其中 QAIC 将
休息一段时间，以观察工作负载是否会生成更多活动。该IRQ
在此期间该行保持禁用状态。如果未检测到任何活动，QAIC 将退出
轮询模式并重新启用IRQ线路。

此缓解措施在QAIC中非常有效。相同的lprnet用例在高负载下每秒生成超过10万次MSI中断（依据 /proc/interrupts），经优化后5分钟内仅发生约64次中断，性能改善显著。
每秒生成超过10万次MSI中断（依据 /proc/interrupts）减少到5分钟内仅约64次，设备会自动将DBC中断重定向至MHI使用的中断通道。
在保持主机系统稳定的同时，5分钟内处理的IRQ超过
工作负载吞吐量性能（在运行间噪声变化范围内）。

单MSI模式
---------

MultiMSI 并非在所有系统上都得到良好支持；虚拟化系统更是如此
（约 2023 年）。在虚拟机监控器屏蔽 PCIe MSI 功能结构之间
vIOMMU 的大型内存需求（支持 MultiMSI 所必需），它会
在需要时能够回退到单个MSI是有用的。

为了支持此回退机制，我们允许仅有一个MSI能够被使用的情况。
已分配，并在MHI和DBC之间共享该MSI。设备检测到
当仅配置了一个MSI并用于引导DBC的中断时
到通常用于MHI的中断。不幸的是，这意味着
每个DBC和MHI的中断处理程序会在每次中断时被唤醒
到达；然而，DBC线程化的中断处理程序仅在有工作需要处理时才启动
检测到完成状态（MHI 将始终启动其线程化处理器）。

如果 DBC 配置为强制使用 MSI 中断，则可以绕过
上述提到的软件IRQ风暴缓解措施。由于MSI是共享的，因此它被
从不被禁用，使得FIFO中的每个新条目都会触发一次新的中断。


神经网络控制（NNC）协议
=======================

NNC 的实现分布在 KMD（QAIC）和 UMD 之间。通常情况下
QAIC 了解如何编码/解码 NNC 线路协议，以及其中的元素，包括协议规定的字节序对齐、事务结构处理，并负责主机内存到设备IOVA的映射；NNC协议要求小端序和64位对齐，部分内容依赖UMD保证。
需要内核空间知识才能处理的协议（例如，映射
host内存到设备IOVA）。QAIC了解消息的结构，并
所有的交易。QAIC 不理解命令（其有效载荷）
passthrough 交易）。

QAIC 处理并强制执行所需的小端字节序和 64 位对齐，
在它能够做到的范围内。由于QAIC并不知道内容
passthrough 交易，它依赖于 UMD 来满足要求。

终止事务对QAIC特别有用。QAIC并不知晓
自那项活动以来加载到设备上的资源，因为大部分该活动
发生在NNC命令中。因此，QAIC没有手段来
回滚用户空间活动。以确保用户空间客户端的资源
在进程崩溃或出现错误的情况下，QAIC会完全释放
终止命令，让 QSM 知道用户已离开，以及相关资源
可以发布。

QSM 可以报告其支持的 NNC 协议的版本号。这是在
主版本号和次版本号的形式。

主版本号的更新表示对NNC协议进行了影响重大的更改
消息格式，或事务（影响QAIC）。

次要版本号更新表示对 NNC 协议的更改，这些更改会影响
命令（不影响 QAIC）。

uAPI
====

QAIC 为每个物理 PCIe 设备创建一个加速设备。此加速设备存在
只要Linux知道该PCIe设备存在，且在其整个生命周期内持续维持。

PCIe设备可能尚未处于可接受来自用户空间请求的状态
所有时间。QAIC 将触发 KOBJ_ONLINE/OFFLINE uevents，以通告
设备可以接受请求（ONLINE），以及当设备不再接受
requests (OFFLINE) 由于重置或其他状态转换。

QAIC 将若干驱动程序特定的 IOCTL 定义为用户空间 API 的一部分。

DRM_IOCTL_QAIC_MANAGE
该IOCTL允许用户空间向QSM发送NNC请求。调用将
阻塞直到收到响应，或请求已超时。

DRM_IOCTL_QAIC_CREATE_BO
此 IOCTL 允许用户空间分配一个缓冲对象（BO），该对象可以发送
或从工作负载接收数据。该调用将返回一个GEM句柄
表示已分配的缓冲区。在完成分配之前，BO 无法使用。
sliced（参见 DRM_IOCTL_QAIC_ATTACH_SLICE_BO）。

DRM_IOCTL_QAIC_MMAP_BO
此 IOCTL 允许用户空间准备已分配的 BO，以便将其 mmap 到
用户空间进程。

DRM_IOCTL_QAIC_ATTACH_SLICE_BO
此IOCTL允许用户空间对BO进行切片，以准备发送该BO。
到设备。切片是描述BO的哪些部分的操作
被发送到工作负载所在的位置。这需要一组用于DMA传输的
DMA桥，因此将BO锁定到特定的DBC上。

DRM_IOCTL_QAIC_EXECUTE_BO
此 IOCTL 允许用户空间向设备提交一组切片的 BO。
调用是非阻塞的。成功仅表示BOs已被排队
发送到设备，但不保证已执行。

DRM_IOCTL_QAIC_PARTIAL_EXECUTE_BO
此 IOCTL 的操作类似于 DRM_IOCTL_QAIC_EXECUTE_BO，但它允许用户空间
以缩小为此特定调用发送到设备的BO。如果一个BO
通常有 N 个输入，但只有其中一部分可用，此 IOCTL
允许用户空间指明BO的前M字节
发送到设备以最小化数据传输开销。该IOCTL动态地
重新计算切片，因此在处理前会有一些处理开销
BO 可以排队到设备中。

DRM_IOCTL_QAIC_WAIT_BO
此 IOCTL 允许用户空间确定特定 BO 何时被
由设备处理。该调用将阻塞，直到BO已被
processed 并可重新排队到设备，或发生超时。

DRM_IOCTL_QAIC_PERF_STATS_BO
此 IOCTL 允许用户空间收集关于最频繁操作的性能统计信息。
最近执行了一个BO。这允许用户空间构建端到端
性能分析中BO处理的时间线。

DRM_IOCTL_QAIC_DETACH_SLICE_BO
此 IOCTL 允许用户空间从 BO 中移除切片信息
最初由对 DRM_IOCTL_QAIC_ATTACH_SLICE_BO 的调用提供。这
是 DRM_IOCTL_QAIC_ATTACH_SLICE_BO 的逆操作。该缓冲对象（BO）必须处于空闲状态，
才能调用 DRM_IOCTL_QAIC_DETACH_SLICE_BO。在成功分离切片后
操作完成后，BO 可通过新的调用重新附加新的切片信息，但需重新计算切片，带来额外性能开销。
到 DRM_IOCTL_QAIC_ATTACH_SLICE_BO。分离切片后，BO 将无法再使用
执行将延迟到新的附加切片操作之后。组合附加切片
并分离切片调用，允许用户空间使用一个缓冲对象（BO）处理多个工作负载。

用户空间客户端隔离
==================

AIC100 支持多个客户端。单个客户端可以使用多个 DBC。
客户端，且多个客户端可以各自消费一个或多个 DBC。工作负载
可能包含敏感信息，因此仅限拥有该信息的客户端访问
应允许工作负载与DBC进行交互。

客户端通过与其 open() 关联的实例来标识。一个客户端
只能使用他们自己分配的内存，以及分配给他们的DBC
工作负载。尝试访问分配给其他客户端的资源将被
已拒绝。

模块参数
========

QAIC 支持以下模块参数：

**datapath_polling (bool)**

配置 QAIC 使用轮询线程来处理数据路径事件，而不是依赖
在设备中断上。适用于具有损坏的多MSI功能的平台。必须
在QAIC驱动初始化时设置。默认为0（关闭）。

**mhi_timeout_ms (unsigned int)**

设置 MHI 操作的超时值（单位：毫秒，ms）。必须进行设置
驱动程序检测到设备时的时间。默认值为2000（2秒）。

**control_resp_timeout_s (unsigned int)**

设置QSM对NNC消息响应的超时值，单位为秒（s）。必须
将在驱动程序向QSM发送请求时设置。默认值为60（一
分钟）。

**wait_exec_default_timeout_ms (unsigned int)**

设置 wait_exec ioctl 的默认超时时间（毫秒）。必须
在 waic_exec ioctl 调用之前设置。ioctl 调用中指定的值
对该调用覆盖此设置。默认值为 5000（5 秒）。

**datapath_poll_interval_us (unsigned int)**

设置数据路径轮询处于活动状态时的轮询间隔（微秒，us）。
在下一个轮询间隔生效。默认值为 100（100 微秒）。

**timesync_delay_ms (无符号整数)**

设置两次时间同步之间的时间间隔（毫秒）
操作。默认为1000（1000毫秒）。


==================================================

由 Qwen-plus 及 LT agent 翻译